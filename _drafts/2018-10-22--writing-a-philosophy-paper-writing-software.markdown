---
layout: post
title:  "Writing a Philosophy Paper. Writing Software."
date:   2018-10-23 18:51:13 +0100
categories: Philosophy
---

Working on the first major assignments in my computer science master, I have come to observe a number of similarities between writing software and a philosophy paper - and one key difference. I am here concerned with software and philosophy papers of a substantial nature, those which are covering more than a tiny and specific issue. My claims are also limited to cases of single authorship for both papers and code.

*You always rely on the work of others*

No piece of software that is more than the most minimal demonstration can be self-contained. It always draws on prior thought. Likewise in philosophy, where you should refer to previous research. When I discuss in my work the nature of group agency, I point to the work of Christian List and Philip Pettit or Deborah Tollefson.

In both cases, the dependence is not just that of a writer relying on their pencil to draw lines, but it is a dependence in the conceptual tools you employ. You depend on others as thoughtful agents, as people how have a reasonable understanding of the world on which you can draw. 

*You spend more time reading than writing*

For philosophy papers, this does not come as surprise to anyone who has ventured to write one. You have to familiarise yourself with the literature, since as mentioned before, you rely on the thoughts of others to make your points. For creating software the need for extextensive this might be more surprising, but you constantly require a look into documentation or at least StackOverflow. In the engineering endeavour you too rely on others and to do so you need to read. In addition, a considerable amount of time goes into studying your own output after writing. You have to reread the source code to debug it and your philosophical work,  my papers often undergo around 30 major revisions before I submit them.

*You are never finished*

The most frustrating similarity, as far as I am concerned, is that neither a substantial piece of software nor a substantial paper is ever finished. You only stop working on it. Unless you have the patience of Donald Knuth you will leave the project in an unfinished, but hopefully acceptable state. You might have improved upon the existing literature, but you rarely reach the end of the inquiry, and even if you did you could still improve the expression. Your philosophical argument could be stated in a better way, you could have addressed another worry, and you neglected to develop one implication. Your code could be cleaner, you regret the choice of one abstraction, and there is a test missing. Looking at the outcome again, you could come up with something else to do.

*One difference*

If the creative product is never finished, how do you know when to stop? What are the criteria for calling it good enough? Here philosophy and software engineering diverge: The program has to provide reasonable output and then you call it a day. With the philosophy paper, the audience matters much more.[0] With minor exceptions,[1] philosophy is not an empirical discipline in which you can follow an accepted methodology and then be sure that you have a result. What matters for philosophy as an academic discipline is the reception by peers, within in peer review and in other contexts. You have to convince your audience. The argument is for them.[2] With the exception of formal areas, where a proof can do wonders, you have read your text with the eyes of the audience. That also helps for getting a paper accepted at NeurIPS, but if your neural network beats the standard and you put the code online who cares about your atrocious writing?

This difference in incentives changes everything. As I already indicated, it changes how you deal with the always unfinished nature of your work. The criterion for stopping differs, because you are writing the paper much more with an eye to how the audience reads it. The difference also affects how you rely on the work of others. It starts to matter whether your author considers your sources sensible. As long as your software performs its services, it does not matter whether you are using a conceptual tool usually frowned up. In addition, all your reading also becomes shaped by the expectation of your audience. I know it from my own experience that I am not just looking for insights upon which I can build, but for quotes that help me make my argument more convincing for the audience. Of course, that applies doubly for rereading your own paper, which often happens in response to comments you receive.

I suggest that the evaluation of the difference should depend on two questions: 1) Is writing for convincing a philosophical audience truth-conducive? 2) Could we do it differently?

A final remark, I am making sweeping generalisation about diverse disciplines and in a matter of degree. Focussing on that one difference helped me understand my own practices better, but I would not suggest to depend on it as the context of your philosophical and software work might differ.

---
[0] User-facing programs such as games, so not the kind of machine learning code for NLP experiments I am writing, are closer to the philosophy paper. However, there remains a difference between using software and reading a paper. The users are not reading the source code, they are making use of what it does. The philosophical audicence reads your paper and scrutinises it.

[1] Such as experimental philosophy, whatever one makes of it.

[2] If you aspire to a career in academia, anyways.